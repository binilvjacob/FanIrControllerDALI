CCS PCM C Compiler, Version 5.015, 5967               12-May-21 19:01

               Filename:   D:\home automation codes\fan pic code\fan slave code\GATE  WAY  WITH  AUTH FUN\ysmen.lst

               ROM used:   1492 words (73%)
                           Largest free fragment is 556
               RAM used:   70 (31%) at main() level
                           88 (39%) worst case
               Stack used: 5 locations (3 in main + 2 for interrupts)
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   54E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   7F,W
0009:  MOVWF  20
000A:  MOVF   0A,W
000B:  MOVWF  27
000C:  CLRF   0A
000D:  SWAPF  20,F
000E:  MOVF   04,W
000F:  MOVWF  22
0010:  MOVF   77,W
0011:  MOVWF  23
0012:  MOVF   78,W
0013:  MOVWF  24
0014:  MOVF   79,W
0015:  MOVWF  25
0016:  MOVF   7A,W
0017:  MOVWF  26
0018:  BCF    03.7
0019:  BCF    03.5
001A:  BTFSS  0B.5
001B:  GOTO   01E
001C:  BTFSC  0B.2
001D:  GOTO   11F
001E:  BTFSS  0B.4
001F:  GOTO   022
0020:  BTFSC  0B.1
0021:  GOTO   039
0022:  MOVLW  8C
0023:  MOVWF  04
0024:  BTFSS  00.0
0025:  GOTO   028
0026:  BTFSC  0C.0
0027:  GOTO   06F
0028:  MOVF   22,W
0029:  MOVWF  04
002A:  MOVF   23,W
002B:  MOVWF  77
002C:  MOVF   24,W
002D:  MOVWF  78
002E:  MOVF   25,W
002F:  MOVWF  79
0030:  MOVF   26,W
0031:  MOVWF  7A
0032:  MOVF   27,W
0033:  MOVWF  0A
0034:  SWAPF  21,W
0035:  MOVWF  03
0036:  SWAPF  7F,F
0037:  SWAPF  7F,W
0038:  RETFIE
....................  
.................... #include <ysmen.h> 
.................... #include <16F628A.h> 
.................... //////////// Standard Header file for the PIC16F628A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F628A 
....................  
.................... #list 
....................  
....................  
.................... #FUSES NOWDT                 	//No Watch Dog Timer 
.................... //#FUSES xt 
.................... #FUSES INTRC_IO                      	//Crystal osc <= 4mhz for PCM/PCH , 3mhz to 10 mhz for PCD 
.................... #FUSES NOPUT                 	//No Power Up Timer  // PUT 
.................... #FUSES PROTECT             	//Code not protected from reading 
.................... #FUSES NOBROWNOUT            	//No brownout reset  // BROWNOUT 
.................... #FUSES MCLR                  	//Master Clear pin enabled 
.................... #FUSES NOLVP                 	//No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                 	//No EE protection 
....................  
.................... #use delay(clock=4000000,RESTART_WDT) 
....................  
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_b2,rcv=PIN_b1,bits=8,DISABLE_INTS) 
....................  
.................... setup_adc( ADC_OFF ); 
.................... //#use rs232(baud=19200,parity=N,xmit=PIN_b2,rcv=PIN_b1,bits=8,TIMEOUT=X 
....................  
....................  
....................  
.................... /////////////////////////////////////////////// 
....................  
.................... //#include <slave.h> 
.................... #include<math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  #include <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0565:  CLRF   28
0566:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define fan_pin pin_b5 
....................  
....................  
....................  
.................... #use delay(clock=4000000) 
*
0233:  MOVLW  61
0234:  MOVWF  04
0235:  BCF    03.7
0236:  MOVF   00,W
0237:  BTFSC  03.2
0238:  GOTO   247
0239:  MOVLW  01
023A:  MOVWF  78
023B:  CLRF   77
023C:  DECFSZ 77,F
023D:  GOTO   23C
023E:  DECFSZ 78,F
023F:  GOTO   23B
0240:  MOVLW  4A
0241:  MOVWF  77
0242:  DECFSZ 77,F
0243:  GOTO   242
0244:  GOTO   245
0245:  DECFSZ 00,F
0246:  GOTO   239
0247:  RETURN
*
0317:  MOVLW  12
0318:  SUBWF  62,F
0319:  BTFSS  03.0
031A:  GOTO   32A
031B:  MOVLW  62
031C:  MOVWF  04
031D:  BCF    03.7
031E:  MOVLW  FC
031F:  ANDWF  00,F
0320:  BCF    03.0
0321:  RRF    00,F
0322:  RRF    00,F
0323:  MOVF   00,W
0324:  BTFSC  03.2
0325:  GOTO   32A
0326:  GOTO   328
0327:  NOP
0328:  DECFSZ 00,F
0329:  GOTO   327
....................  
.................... /////////// Driver details /////////////////// 
.................... /* 
.................... fan driver 
....................  
.................... */ 
.................... ///////////////////////////////////////////////// 
....................  
.................... #define device_type 2 /////////// setting device type  
....................  
....................  
.................... #define Fixlampid 128             // LAMP ADDRESS // 
.................... #define zoneid_init   219 // zone address // 1-6 192//,5-8 193//,9-12 194//,13-16 195// 
.................... #define G1 0b00000001 
.................... #define G2 0b00000000 
.................... #define rx pin_B0 
.................... #define tx pin_A2 
.................... #define self 0x01 
....................  
.................... #define MaxDuty  100 //254 1 led 53,2- 58,3-95 
.................... #define MinDuty  0//10  
....................  
....................  
.................... /////////////////////////////////////////////////////////////// 
....................  
.................... #define PowerOnLevelStore    		0           //[0] 
.................... #define SystemFailureLevelStore  	    1           //[1] 
.................... #define MinimumLevelStore           	2			// [2] 
.................... #define MaximumLevelStore  			3 			// [3] 
.................... #define FadeRateStore      			4  			//[4] 
.................... #define FadeTimeStore       			5			//[5] 
.................... #define ShortAddressStore  			6  			//[6] 
.................... #define Group_07Store    			7			//[7] 
.................... #define Group_815Store  			8			///15 [8] 
.................... #define SceneStore  				9			//15 [9-24]/ 
.................... #define RandomAddressStore0  			25			//[25-27] 
.................... #define RandomAddressStore1  			26			//[25-27] 
.................... #define RandomAddressStore2  			27			//[25-27] 
.................... #define FastFadeTimeStore  			28			//[28] 
.................... #define FailureStatusStore  			29			//[29] 
.................... #define OperatingModeStore  30 //[30] 
.................... #define DimmingCurveStore  31   //[31]      
.................... #define ZoneIDStore 32 
....................  
....................  
....................  
.................... ////////////////// Device types //////////////////////// 
.................... /* 
.................... 	lamp =1 
.................... 	fan=2 
.................... 	curtain=3 
.................... 	strip=4 
.................... */ 
.................... //////////////////////////////////////////////////////// 
....................  
.................... #byte dutyreg = 0x15 
....................   
.................... #bit intf = 0x0b.1 
.................... #bit timerOnOff =0x10.0 
....................  
.................... int1 oddevenbit,a,atmp,b,error_flag,over_flowflag; 
.................... unsigned int8 dataCount; 
.................... char data[3],bitcount,tout; 
....................  
....................  
.................... unsigned char fan_duty; 
.................... char settling_time,i,dly=4,j; 
.................... int1 txmit_error; 
.................... char tx_buffer[3]; 
.................... char r_a,currentSceen; 
.................... char command_st,RetryCount; 
....................  
.................... char zoneid=zoneid_init; 
....................  
....................  
.................... char stopBitCount,address ,command,databyte; 
.................... int1 dataready,forwrdFrameFlag,backwardFrameFlag ,masterFlag ; 
.................... int16 readDly=300; 
.................... int16 GroupSelectReg; 
.................... char gindex; 
.................... /////// new  ////// 
.................... int txmit_count=0; 
.................... /////////////////// 
....................  
.................... char MinimumLevel=0; 
.................... char MaximumLevel=100; 
.................... char SystemFailureLevel; 
.................... char FadeRate; 
.................... char FadeTime; 
.................... char RandomAddress0; 
.................... char RandomAddress1; 
.................... char RandomAddress2; 
.................... char FastFadeTime; 
.................... char FailureStatus; 
.................... char OperatingMode; 
.................... char DimmingCurv; 
.................... char PowerOnLevel; 
.................... char DTR,DwriteLocation,DTR_Ready; 
....................  
.................... char lampid  = Fixlampid; 
....................  
.................... void readData(void); 
.................... void init(void); 
.................... void handle(void ); 
.................... void copyData(void); 
.................... void commands(void); 
.................... void txmit(char priority,char length); 
.................... void txmit1(void); 
.................... void txmit0(void); 
.................... void stopbit(void); 
.................... void lamp_on(void); 
.................... void lamp_off(void); 
.................... void startBit(void); 
.................... void init_from_eeprom(void); 
.................... void flash_IR(unsigned char); 
....................  
.................... char dummy_speed; 
.................... /* 
.................... void power(); 
.................... void speed_minus(); 
.................... void boost(); 
.................... void speed_plus(); 
.................... void led(); 
.................... */ 
.................... /* 
.................... void speed_one(); 
.................... void speed_two(); 
.................... void speed_three(); 
.................... void speed_four(); 
.................... void speed_five(); 
.................... void speed_six(); 
.................... void speed_zero(); 
.................... */ 
....................  
.................... #rom  0x2100={MaxDuty,50,MinDuty,Maxduty,5,6,Fixlampid,G1,G2,6,7,8} 
....................  
.................... #rom  0x2120={zoneid_init} 
....................  
....................  
.................... #int_EXT 
.................... EXT_isr()  
.................... { 
.................... 		restart_wdt(); 		 
*
0039:  CLRWDT
....................             disable_interrupts(int_ext); 
003A:  BCF    0B.4
....................             disable_interrupts(INT_RTCC); 
003B:  BCF    0B.5
....................             bitcount=0; 
003C:  CLRF   33
....................             setup_timer_1(T1_internal|T1_div_by_1); 
003D:  MOVLW  85
003E:  MOVWF  10
....................             set_timer1(0xffff-840); //858  880///old value 923 
003F:  CLRF   0E
0040:  MOVLW  FC
0041:  MOVWF  0F
0042:  MOVLW  B7
0043:  MOVWF  0E
....................             enable_interrupts(int_timer1); 
0044:  BSF    03.5
0045:  BSF    0C.0
....................             stopBitCount = 0; 
0046:  BCF    03.5
0047:  CLRF   42
....................             oddevenbit=1; 
0048:  BSF    2E.0
....................             data[0]=0; 
0049:  CLRF   30
....................             data[1]=0; 
004A:  CLRF   31
....................             data[2]=0; 
004B:  CLRF   32
....................             tout=0 ; 
004C:  CLRF   34
....................             datacount = 0;    
004D:  CLRF   2F
.................... 			settling_time = 0;  
004E:  CLRF   36
.................... 			return(0); 
004F:  MOVLW  00
0050:  MOVWF  78
.................... } 
....................  
....................  
....................  
....................  
0051:  BCF    0B.1
0052:  BCF    0A.3
0053:  GOTO   028
.................... #int_TIMER1 
.................... TIMER1_isr() 
.................... { 
....................  
....................  
.................... readDly=20; 
*
006F:  CLRF   48
0070:  MOVLW  14
0071:  MOVWF  47
.................... error_flag=0; 
0072:  BCF    2E.4
.................... 	if(oddevenbit==1) 
0073:  BTFSS  2E.0
0074:  GOTO   0B0
.................... 	{ 
.................... 	//	output_high(pin_c3); 
.................... 		a=input(rx);  
0075:  BSF    03.5
0076:  BSF    06.0
0077:  BCF    03.5
0078:  BCF    2E.1
0079:  BTFSC  06.0
007A:  BSF    2E.1
.................... 		atmp=a ;           
007B:  BCF    2E.2
007C:  BTFSC  2E.1
007D:  BSF    2E.2
.................... 		oddevenbit=0 ; 
007E:  BCF    2E.0
.................... 		 
.................... 				if(atmp) 
007F:  BTFSS  2E.2
0080:  GOTO   097
.................... 				{ 
.................... 					while(atmp) 
0081:  BTFSS  2E.2
0082:  GOTO   096
.................... 						{ 
.................... 							atmp=input(rx); 
0083:  BSF    03.5
0084:  BSF    06.0
0085:  BCF    03.5
0086:  BCF    2E.2
0087:  BTFSC  06.0
0088:  BSF    2E.2
.................... 							if(readDly>0) 
0089:  MOVF   47,F
008A:  BTFSS  03.2
008B:  GOTO   08F
008C:  MOVF   48,F
008D:  BTFSC  03.2
008E:  GOTO   094
.................... 								readDly--; 
008F:  MOVF   47,W
0090:  BTFSC  03.2
0091:  DECF   48,F
0092:  DECF   47,F
0093:  GOTO   095
.................... 							else 
.................... 								atmp=0; 
0094:  BCF    2E.2
0095:  GOTO   081
.................... 								 
.................... 						} 
.................... 				}          
0096:  GOTO   0A8
.................... 				else 
.................... 				{ 
.................... 					while(!atmp) 
0097:  BTFSC  2E.2
0098:  GOTO   0A8
.................... 						{ 
.................... 							atmp=input(rx); 
0099:  BSF    03.5
009A:  BSF    06.0
009B:  BCF    03.5
009C:  BCF    2E.2
009D:  BTFSC  06.0
009E:  BSF    2E.2
.................... 							readDly--; 
009F:  MOVF   47,W
00A0:  BTFSC  03.2
00A1:  DECF   48,F
00A2:  DECFSZ 47,F
.................... 								if(readdly==0) 
00A3:  GOTO   0A7
00A4:  MOVF   48,F
00A5:  BTFSC  03.2
.................... 									{ 
.................... 									atmp=1; 
00A6:  BSF    2E.2
.................... 									}	 
00A7:  GOTO   097
.................... 						} 
.................... 				} 
....................  
.................... 			setup_timer_1(T1_internal|T1_div_by_1);//settimer1with1us least count 
00A8:  MOVLW  85
00A9:  MOVWF  10
.................... 			set_timer1(0xffff-150);  //374  //  355             350////old value 150 
00AA:  CLRF   0E
00AB:  MOVLW  FF
00AC:  MOVWF  0F
00AD:  MOVLW  69
00AE:  MOVWF  0E
.................... 	} 
00AF:  GOTO   11A
.................... 	else 
.................... 	{  
.................... 	//	output_low(pin_c3); 
.................... 		b=input(rx) ; // store data line status in the second half 
00B0:  BSF    03.5
00B1:  BSF    06.0
00B2:  BCF    03.5
00B3:  BCF    2E.3
00B4:  BTFSC  06.0
00B5:  BSF    2E.3
.................... 		oddevenbit=1; 
00B6:  BSF    2E.0
.................... 		setup_timer_1(T1_internal|T1_div_by_1); 
00B7:  MOVLW  85
00B8:  MOVWF  10
.................... 		set_timer1(0xffff-350);  // delay  till the next call st to 73 us/////old value 350 
00B9:  CLRF   0E
00BA:  MOVLW  FE
00BB:  MOVWF  0F
00BC:  MOVLW  A1
00BD:  MOVWF  0E
.................... 		readData();  // function  get the dat from the conditions of a and b 
.................... 					 
.................... 	} 
.................... return(0); 
*
011A:  MOVLW  00
011B:  MOVWF  78
....................  
....................  
....................  
....................  
....................  
.................... } 
....................  
011C:  BCF    0C.0
011D:  BCF    0A.3
011E:  GOTO   028
.................... #int_RTCC 
.................... RTCC_isr() 
.................... {	 
.................... 	restart_wdt();  
011F:  CLRWDT
.................... 	dly--; 
0120:  DECFSZ 38,F
....................   	if (dly == 0) 
0121:  GOTO   128
....................   	{	 
....................       dly = 4; 
0122:  MOVLW  04
0123:  MOVWF  38
....................       if(settling_time < 25) 
0124:  MOVF   36,W
0125:  SUBLW  18
0126:  BTFSC  03.0
....................       { 
....................           settling_time++; 
0127:  INCF   36,F
....................       }               
....................    }  
.................... return(1);   
0128:  MOVLW  01
0129:  MOVWF  78
....................  
012A:  BCF    0B.2
012B:  BCF    0A.3
012C:  GOTO   028
.................... } 
....................  
....................  
.................... void main(void) 
*
054E:  MOVF   03,W
054F:  ANDLW  1F
0550:  MOVWF  03
0551:  BSF    03.5
0552:  BSF    0E.3
0553:  MOVLW  04
0554:  BCF    03.5
0555:  MOVWF  38
0556:  MOVLW  DB
0557:  MOVWF  41
0558:  MOVLW  01
0559:  MOVWF  48
055A:  MOVLW  2C
055B:  MOVWF  47
055C:  CLRF   4C
055D:  CLRF   4D
055E:  MOVLW  64
055F:  MOVWF  4E
0560:  MOVLW  80
0561:  MOVWF  5D
0562:  MOVLW  07
0563:  MOVWF  1F
0564:  BCF    03.7
....................  
.................... { 
.................... 	init_from_eeprom(); 
*
0567:  CALL   12D
.................... 	init();	 
0568:  GOTO   213
.................... 	Minimumlevel=0; 
0569:  CLRF   4D
.................... 	Maximumlevel=100;	 
056A:  MOVLW  64
056B:  MOVWF  4E
.................... 	GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
056C:  MOVLW  08
056D:  BSF    03.5
056E:  MOVWF  1B
056F:  BCF    1C.7
0570:  BSF    1C.0
0571:  MOVF   1A,W
0572:  BCF    03.5
0573:  MOVWF  5F
0574:  MOVLW  07
0575:  BSF    03.5
0576:  MOVWF  1B
0577:  BCF    1C.7
0578:  BSF    1C.0
0579:  MOVF   1A,W
057A:  BCF    03.5
057B:  MOVWF  60
057C:  MOVF   5F,W
057D:  MOVWF  4A
057E:  MOVF   60,W
057F:  MOVWF  49
.................... 	PowerOnLevel = read_EEPROM (PowerOnLevelStore); 
0580:  BSF    03.5
0581:  CLRF   1B
0582:  BCF    1C.7
0583:  BSF    1C.0
0584:  MOVF   1A,W
0585:  BCF    03.5
0586:  MOVWF  59
.................... 	if(PowerOnLevel<= 2) 
0587:  MOVF   59,W
0588:  SUBLW  02
0589:  BTFSS  03.0
058A:  GOTO   58D
.................... 	{ 
.................... 	 	fan_duty=0;		 
058B:  CLRF   35
.................... 	} 
058C:  GOTO   58F
.................... 	else 
.................... 	{ 
.................... 		fan_duty = PowerOnLevel;		 
058D:  MOVF   59,W
058E:  MOVWF  35
.................... 	} 
.................... 	if(fan_duty>=0 && fan_duty<=10) 
058F:  MOVF   35,W
0590:  SUBLW  0A
0591:  BTFSS  03.0
0592:  GOTO   596
.................... 	{ 
.................... 	flash_IR(fan_duty); 
0593:  MOVF   35,W
0594:  MOVWF  5F
0595:  CALL   248
.................... 	} 
.................... start: 
.................... //output_toggle(pin_C3); 
.................... 	/* 
.................... 	flash_IR(5); 
.................... 	delay_ms(3000); 
.................... 	flash_IR(15); 
.................... 	delay_ms(3000); 
.................... 	flash_IR(25); 
.................... 	delay_ms(3000); 
.................... 	flash_IR(45); 
.................... 	delay_ms(3000); 
.................... 	flash_IR(65); 
.................... 	delay_ms(3000); 
.................... 	flash_IR(85); 
.................... 	delay_ms(3000); 
.................... 	flash_IR(105); 
.................... 	delay_ms(3000); 
.................... 	*/ 
.................... 	 
.................... //	speed_minus(); 
....................  
.................... 	//set_pwm1_duty(0); 
....................  
....................  
.................... /////////////////////////////  
....................  
.................... 	restart_wdt(); 	 
0596:  CLRWDT
.................... 	if (dataReady ==1) 
0597:  BTFSS  2E.7
0598:  GOTO   5C5
.................... 	{ 
.................... 		if(address == 0xff) 
0599:  INCFSZ 43,W
059A:  GOTO   59D
.................... 		{ 
.................... 			handle();  
059B:  CALL   399
.................... 		}		 
059C:  GOTO   5C4
.................... 		else if(address==lampid)		{ 
059D:  MOVF   5D,W
059E:  SUBWF  43,W
059F:  BTFSS  03.2
05A0:  GOTO   5A3
.................... 			 
.................... 			handle();  
05A1:  CALL   399
.................... 		}		 
05A2:  GOTO   5C4
....................     	else if(address == zoneid) 
05A3:  MOVF   41,W
05A4:  SUBWF  43,W
05A5:  BTFSS  03.2
05A6:  GOTO   5A9
.................... 		{ 
.................... 			handle();	 
05A7:  CALL   399
.................... 		} 
05A8:  GOTO   5C4
.................... 		else if(address>191 && address<209) 
05A9:  MOVF   43,W
05AA:  SUBLW  BF
05AB:  BTFSC  03.0
05AC:  GOTO   5C4
05AD:  MOVF   43,W
05AE:  SUBLW  D0
05AF:  BTFSS  03.0
05B0:  GOTO   5C4
.................... 		{	 
.................... 			gindex = address &0x0F; 
05B1:  MOVF   43,W
05B2:  ANDLW  0F
05B3:  MOVWF  4B
.................... 			if ( bit_test (GroupSelectReg, gindex)==1) 
05B4:  MOVF   4A,W
05B5:  MOVWF  7A
05B6:  MOVF   49,W
05B7:  MOVWF  79
05B8:  MOVF   4B,W
05B9:  MOVWF  77
05BA:  BTFSC  03.2
05BB:  GOTO   5C1
05BC:  BCF    03.0
05BD:  RRF    7A,F
05BE:  RRF    79,F
05BF:  DECFSZ 77,F
05C0:  GOTO   5BC
05C1:  MOVF   79,W
05C2:  BTFSC  79.0
.................... 			{ 				 
.................... 				handle(); 
05C3:  CALL   399
.................... 			}	 
.................... 		} 
.................... 		dataReady =0; 
05C4:  BCF    2E.7
.................... 	} 
.................... 	if(txmit_error==1 && txmit_count<64) 
05C5:  BTFSS  2E.6
05C6:  GOTO   5D1
05C7:  MOVF   4C,W
05C8:  SUBLW  3F
05C9:  BTFSS  03.0
05CA:  GOTO   5D1
.................... 	{ 
.................... 		txmit_count++; 
05CB:  INCF   4C,F
.................... 		txmit(2,2); 
05CC:  MOVLW  02
05CD:  MOVWF  5F
05CE:  MOVWF  60
05CF:  CALL   32D
.................... 	}	 
05D0:  GOTO   5D2
.................... 	else 
.................... 	{ 
.................... 		txmit_count=0; 
05D1:  CLRF   4C
.................... 	} 
....................  
.................... ///////////////////////////  
.................... 	//power(); 
.................... 	//delay_ms(4000); 
.................... 	//output_high(pin_b3); 
....................  
....................  
.................... 	goto start; 
05D2:  GOTO   596
.................... } 
....................  
05D3:  SLEEP
.................... void init(void) 
....................  
.................... { 
.................... 	setup_timer_2(T2_DIV_BY_1,25,1);		//26.0 us overflow, 26.0 us interrupt 
*
0213:  MOVLW  00
0214:  MOVWF  78
0215:  IORLW  04
0216:  MOVWF  12
0217:  MOVLW  19
0218:  BSF    03.5
0219:  MOVWF  12
....................  //	setup_ccp1(CCP_PWM); 
.................... //	set_pwm1_duty((int16)10);	 
.................... 	setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
021A:  MOVF   01,W
021B:  ANDLW  C7
021C:  IORLW  08
021D:  MOVWF  01
.................... 	//setup_wdt(WDT_2304MS|WDT_DIV_16); 
.................... 	setup_timer_1(T1_internal|T1_div_by_1); 
021E:  MOVLW  85
021F:  BCF    03.5
0220:  MOVWF  10
.................... 	timerOnOff=0; 
0221:  BCF    10.0
.................... 	ext_int_edge( H_TO_L ); 
0222:  BSF    03.5
0223:  BCF    01.6
.................... 	enable_interrupts(INT_EXT); 
0224:  BCF    03.5
0225:  BSF    0B.4
.................... 	enable_interrupts(INT_RTCC); 
0226:  BSF    0B.5
.................... 	enable_interrupts(global);	 
0227:  MOVLW  C0
0228:  IORWF  0B,F
.................... 	settling_time =23; 
0229:  MOVLW  17
022A:  MOVWF  36
.................... 	dataReady =0;	 
022B:  BCF    2E.7
.................... 	set_pwm1_duty((int16)0); 
022C:  CLRF   15
022D:  MOVF   17,W
022E:  ANDLW  CF
022F:  MOVWF  17
.................... 	/*power(); 
.................... 	delay_ms(2000); 
.................... 	power();*/ 
.................... 	setup_ccp1(CCP_OFF); 
0230:  MOVLW  F0
0231:  ANDWF  17,F
.................... 	return; 
0232:  GOTO   569 (RETURN)
.................... } 
....................  
....................  
....................  
.................... void handle(void ) 
....................  
.................... { 
.................... 	commands(); 
.................... 	delay_ms(2); 
*
0549:  MOVLW  02
054A:  MOVWF  61
054B:  CALL   233
.................... 	RetryCount =0; 
054C:  CLRF   40
....................  
.................... return; 
054D:  RETURN
....................  
.................... } 
....................  
....................  
.................... //				trnsmission of  bit 1			// 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  bit 1 to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit1(void) 
....................  
.................... {      
....................   	txmit_error = 0; 
*
02BD:  BCF    2E.6
.................... 	if (input(rx)==1) 
02BE:  BSF    03.5
02BF:  BSF    06.0
02C0:  BCF    03.5
02C1:  BTFSS  06.0
02C2:  GOTO   2C7
.................... 	{   
.................... 		output_bit(tx,0); 
02C3:  BCF    05.2
02C4:  BSF    03.5
02C5:  BCF    05.2
02C6:  BCF    03.5
.................... 	} 
.................... 	delay_us(79); 
02C7:  MOVLW  19
02C8:  MOVWF  77
02C9:  DECFSZ 77,F
02CA:  GOTO   2C9
02CB:  GOTO   2CC
02CC:  NOP
.................... 	if (input(rx)==1) 
02CD:  BSF    03.5
02CE:  BSF    06.0
02CF:  BCF    03.5
02D0:  BTFSS  06.0
02D1:  GOTO   2D8
.................... 	{ 
.................... 		output_bit(tx,1); 
02D2:  BSF    05.2
02D3:  BSF    03.5
02D4:  BCF    05.2
.................... 		txmit_error = 1; 
02D5:  BCF    03.5
02D6:  BSF    2E.6
.................... 		return; 
02D7:  GOTO   30D
.................... 	}			   
.................... 	delay_us(290);//345 
02D8:  MOVLW  60
02D9:  MOVWF  77
02DA:  DECFSZ 77,F
02DB:  GOTO   2DA
02DC:  NOP
.................... 	if (input(rx)==0) 
02DD:  BSF    03.5
02DE:  BSF    06.0
02DF:  BCF    03.5
02E0:  BTFSC  06.0
02E1:  GOTO   2E7
.................... 	{ 
.................... 		output_bit(tx,1); 
02E2:  BSF    05.2
02E3:  BSF    03.5
02E4:  BCF    05.2
.................... 	} 
02E5:  GOTO   2EE
02E6:  BCF    03.5
.................... 	else 
.................... 	{ 
.................... 		output_bit(tx,1); 
02E7:  BSF    05.2
02E8:  BSF    03.5
02E9:  BCF    05.2
.................... 		txmit_error = 1; 
02EA:  BCF    03.5
02EB:  BSF    2E.6
.................... 		return; 
02EC:  GOTO   30D
02ED:  BSF    03.5
.................... 	} 
.................... 	delay_us(79); 
02EE:  MOVLW  19
02EF:  MOVWF  77
02F0:  DECFSZ 77,F
02F1:  GOTO   2F0
02F2:  GOTO   2F3
02F3:  NOP
.................... 	if (input(rx)==0) 
02F4:  BSF    06.0
02F5:  BCF    03.5
02F6:  BTFSC  06.0
02F7:  GOTO   2FE
.................... 	{ 
.................... 		output_bit(tx,1); 
02F8:  BSF    05.2
02F9:  BSF    03.5
02FA:  BCF    05.2
.................... 		txmit_error = 1; 
02FB:  BCF    03.5
02FC:  BSF    2E.6
.................... 		return; 
02FD:  GOTO   30D
.................... 	} 
....................     delay_us(290); 
02FE:  MOVLW  60
02FF:  MOVWF  77
0300:  DECFSZ 77,F
0301:  GOTO   300
0302:  NOP
.................... 	if (input(rx)==0) 
0303:  BSF    03.5
0304:  BSF    06.0
0305:  BCF    03.5
0306:  BTFSC  06.0
0307:  GOTO   30D
.................... 	{ 
.................... 		output_bit(tx,1); 
0308:  BSF    05.2
0309:  BSF    03.5
030A:  BCF    05.2
.................... 		txmit_error = 1; 
030B:  BCF    03.5
030C:  BSF    2E.6
.................... 		return; 
.................... 	} 
....................     return; 
030D:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //         transmission of 0 to the bus      // 
.................... /********************************************************************* 
....................  * Function:       void txmit0(void); 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          transmission of  0 bit to the bus	 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
.................... **********************************************************************/ 
....................  
.................... void txmit0(void) 
....................  
.................... { 
.................... 	txmit_error = 0;	 
*
034A:  BCF    2E.6
.................... 	output_bit(tx,1); 
034B:  BSF    05.2
034C:  BSF    03.5
034D:  BCF    05.2
.................... 	delay_us(79); 
034E:  MOVLW  19
034F:  MOVWF  77
0350:  DECFSZ 77,F
0351:  GOTO   350
0352:  GOTO   353
0353:  NOP
.................... 	if (input(rx)!=1) 
0354:  BSF    06.0
0355:  BCF    03.5
0356:  BTFSC  06.0
0357:  GOTO   35A
.................... 	{		 
.................... 		txmit_error = 1; 
0358:  BSF    2E.6
.................... 		return; 
0359:  GOTO   387
.................... 	}    
.................... 	delay_us(290); 
035A:  MOVLW  60
035B:  MOVWF  77
035C:  DECFSZ 77,F
035D:  GOTO   35C
035E:  NOP
.................... 	if (input(rx)==1) 
035F:  BSF    03.5
0360:  BSF    06.0
0361:  BCF    03.5
0362:  BTFSS  06.0
0363:  GOTO   369
.................... 	{ 
.................... 		output_bit(tx,0); 
0364:  BCF    05.2
0365:  BSF    03.5
0366:  BCF    05.2
.................... 	} 
0367:  GOTO   370
0368:  BCF    03.5
....................     else 
.................... 	{ 
.................... 		output_bit(tx,1); 
0369:  BSF    05.2
036A:  BSF    03.5
036B:  BCF    05.2
.................... 		txmit_error = 1; 
036C:  BCF    03.5
036D:  BSF    2E.6
.................... 		return; 
036E:  GOTO   387
036F:  BSF    03.5
.................... 	} 
....................     delay_us(79); 
0370:  MOVLW  19
0371:  MOVWF  77
0372:  DECFSZ 77,F
0373:  GOTO   372
0374:  GOTO   375
0375:  NOP
....................     if (input(rx)==1) 
0376:  BSF    06.0
0377:  BCF    03.5
0378:  BTFSS  06.0
0379:  GOTO   37C
.................... 	{		 
.................... 		txmit_error = 1; 
037A:  BSF    2E.6
.................... 		return; 
037B:  GOTO   387
.................... 	} 
....................     delay_us(290); 
037C:  MOVLW  60
037D:  MOVWF  77
037E:  DECFSZ 77,F
037F:  GOTO   37E
0380:  NOP
.................... 	if (input(rx)==1) 
0381:  BSF    03.5
0382:  BSF    06.0
0383:  BCF    03.5
0384:  BTFSS  06.0
0385:  GOTO   387
.................... 	{		 
.................... 		txmit_error = 1; 
0386:  BSF    2E.6
.................... 		return; 
.................... 	} 
....................     return; 
.................... } 
.................... //----------------------------------------------------------------------------- 
....................                    // txmit2 bit 
.................... //----------------------------------------------------------------------------- 
....................  
.................... void txmit(char priority,char length) 
.................... {  
....................      j= 8*length; 
*
032D:  RLF    60,W
032E:  MOVWF  39
032F:  RLF    39,F
0330:  RLF    39,F
0331:  MOVLW  F8
0332:  ANDWF  39,F
.................... 	 while (settling_time < 12+priority);      // priority 
0333:  MOVLW  0C
0334:  ADDWF  5F,W
0335:  SUBWF  36,W
0336:  BTFSS  03.0
0337:  GOTO   333
....................      disable_interrupts(global); 
0338:  BCF    0B.6
0339:  BCF    0B.7
033A:  BTFSC  0B.7
033B:  GOTO   339
....................      txmit1();        // start bit   
033C:  CALL   2BD
....................      for(i=0;i<j;i++) 
033D:  CLRF   37
033E:  MOVF   39,W
033F:  SUBWF  37,W
0340:  BTFSC  03.0
0341:  GOTO   38B
....................          { 
....................             if (shift_left(tx_buffer,3,1)==1) 
0342:  BSF    03.0
0343:  RLF    3A,F
0344:  RLF    3B,F
0345:  RLF    3C,F
0346:  BTFSS  03.0
0347:  GOTO   34A
....................             { 
....................                  txmit1(); 
0348:  CALL   2BD
....................             } 
0349:  GOTO   387
....................             else 
....................             { 
....................                   txmit0(); 
....................             } 
....................             if (txmit_error ==1) 
*
0387:  BTFSC  2E.6
....................             { 
....................                goto rr; 
0388:  GOTO   38F
....................             }		 
0389:  INCF   37,F
038A:  GOTO   33E
....................          }         
....................      stopbit();     
038B:  CALL   30E
....................      stopbit();  
038C:  CALL   30E
.................... 	stopbit(); stopbit(); 
038D:  CALL   30E
038E:  CALL   30E
.................... rr:  output_bit(tx,1); 
038F:  BSF    05.2
0390:  BSF    03.5
0391:  BCF    05.2
.................... 	 settling_time = 0; 
0392:  BCF    03.5
0393:  CLRF   36
....................      intf =0; 
0394:  BCF    0B.1
....................      enable_interrupts(global);	 
0395:  MOVLW  C0
0396:  IORWF  0B,F
.................... 	 enable_interrupts(INT_RTCC); 
0397:  BSF    0B.5
....................      return; 
0398:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................           // stop bit function // 
.................... //-------------------------------------------------------------------------- 
.................... void  stopbit(void) 
.................... { 
....................       output_bit(tx,1); 
*
030E:  BSF    05.2
030F:  BSF    03.5
0310:  BCF    05.2
.................... 	  restart_wdt();  
0311:  CLRWDT
....................       delay_us(830); 
0312:  MOVLW  05
0313:  BCF    03.5
0314:  MOVWF  61
0315:  MOVLW  A3
0316:  MOVWF  62
*
032A:  DECFSZ 61,F
032B:  GOTO   315
....................       return; 
032C:  RETURN
.................... } 
....................  
.................... //-------------------------------------------------------------------------- 
....................  
....................  
.................... void readData(void) 
.................... { 
.................... 	restart_wdt();  
*
00BE:  CLRWDT
....................       error_flag=0; 
00BF:  BCF    2E.4
....................       datacount++; 
00C0:  INCF   2F,F
....................       forwrdFrameFlag = 0; 
00C1:  BCF    46.0
.................... 	  backwardFrameFlag =0; 
00C2:  BCF    46.1
....................       if(datacount< 27) 
00C3:  MOVF   2F,W
00C4:  SUBLW  1A
00C5:  BTFSS  03.0
00C6:  GOTO   115
....................       { 
....................          if((a==0 )&& (b==1)) 
00C7:  BTFSC  2E.1
00C8:  GOTO   0D0
00C9:  BTFSS  2E.3
00CA:  GOTO   0D0
....................          { 
....................             shift_left(data,3,1);  // a one  detewcted on bus  
00CB:  BSF    03.0
00CC:  RLF    30,F
00CD:  RLF    31,F
00CE:  RLF    32,F
....................          } 
00CF:  GOTO   114
....................          else if((a==1)&&(b==0)) 
00D0:  BTFSS  2E.1
00D1:  GOTO   0D9
00D2:  BTFSC  2E.3
00D3:  GOTO   0D9
....................          { 
....................             shift_left(data,3,0);  // a zero is  deted on the bus  
00D4:  BCF    03.0
00D5:  RLF    30,F
00D6:  RLF    31,F
00D7:  RLF    32,F
....................          } 
00D8:  GOTO   114
....................          else if ( a==1 && b==1) 
00D9:  BTFSS  2E.1
00DA:  GOTO   10F
00DB:  BTFSS  2E.3
00DC:  GOTO   10F
....................          { 
....................             switch (datacount) 
00DD:  MOVF   2F,W
00DE:  XORLW  11
00DF:  BTFSC  03.2
00E0:  GOTO   0EB
00E1:  XORLW  03
00E2:  BTFSC  03.2
00E3:  GOTO   0ED
00E4:  XORLW  0B
00E5:  BTFSC  03.2
00E6:  GOTO   0FB
00E7:  XORLW  03
00E8:  BTFSC  03.2
00E9:  GOTO   0FD
00EA:  GOTO   10A
....................             { 
....................                case 17: 
....................                { 
....................                      stopBitCount ++; 
00EB:  INCF   42,F
....................                      break; 
00EC:  GOTO   10E
....................                } 
....................                case 18: 
....................                { 
....................                   stopBitCount ++; 
00ED:  INCF   42,F
....................                   if(stopBitCount == 2) 
00EE:  MOVF   42,W
00EF:  SUBLW  02
00F0:  BTFSS  03.2
00F1:  GOTO   0F9
....................                   { 
....................                         r_a=1;  
00F2:  MOVLW  01
00F3:  MOVWF  3D
....................                         copyData(); 
00F4:  CALL   054
....................                         forwrdFrameFlag = 1; 
00F5:  BSF    46.0
....................                         masterflag = 0; 
00F6:  BCF    46.2
....................                         backwardFrameFlag =0; 
00F7:  BCF    46.1
....................  
....................                   } 
00F8:  GOTO   0FA
....................                   else 
....................                   { 
.................... 						error_flag =1; 
00F9:  BSF    2E.4
....................                   } 
....................                   break; 
00FA:  GOTO   10E
....................                } 
....................               	case 25: 
.................... 				{ 
.................... 					stopBitCount ++; 
00FB:  INCF   42,F
.................... 					break; 
00FC:  GOTO   10E
.................... 				} 
....................               	case 26:  
.................... 				{ 
.................... 					stopBitCount ++; 
00FD:  INCF   42,F
.................... 					if(stopBitCount == 2) 
00FE:  MOVF   42,W
00FF:  SUBLW  02
0100:  BTFSS  03.2
0101:  GOTO   108
.................... 					{ 
.................... 						r_a=0;  
0102:  CLRF   3D
.................... 						copyData(); 
0103:  CALL   054
.................... 						forwrdFrameFlag =0; 
0104:  BCF    46.0
.................... 						masterflag = 1; 
0105:  BSF    46.2
.................... 						backwardFrameFlag =0; 
0106:  BCF    46.1
.................... 					} 
0107:  GOTO   109
.................... 					else 
.................... 					{ 
.................... 						error_flag =1; 
0108:  BSF    2E.4
.................... 					} 
.................... 					break; 
0109:  GOTO   10E
.................... 				} 
....................                 default: 
....................                 { 
....................                       error_flag=1; 
010A:  BSF    2E.4
....................                       timerOnOff=0; 
010B:  BCF    10.0
....................                       enable_interrupts(INT_EXT); 
010C:  BSF    0B.4
....................                       settling_time = 0; 
010D:  CLRF   36
....................                       break; 
....................                 } 
....................              }    
....................           }  
010E:  GOTO   114
.................... 		else 
.................... 		{ 
.................... 			error_flag=1;     
010F:  BSF    2E.4
.................... 			settling_time = 0; 
0110:  CLRF   36
.................... 			timerOnOff=0;        
0111:  BCF    10.0
.................... 			enable_interrupts(INT_EXT);        
0112:  BSF    0B.4
.................... 			enable_interrupts(INT_RTCC);          
0113:  BSF    0B.5
.................... 		} 
....................       } 
0114:  GOTO   11A
.................... 	else  // the  data count grater than 27  
.................... 	{ 
.................... 		over_flowflag =1 ; 
0115:  BSF    2E.5
.................... 		settling_time = 0; 
0116:  CLRF   36
.................... 		timerOnOff=0;        
0117:  BCF    10.0
.................... 		enable_interrupts(INT_EXT);        
0118:  BSF    0B.4
.................... 		enable_interrupts(INT_RTCC);          
0119:  BSF    0B.5
.................... 	} 
....................     return; 
.................... } 
....................  
....................  
....................  
....................  
.................... void copyData(void) 
.................... {  
.................... 	restart_wdt();  
*
0054:  CLRWDT
.................... 	dataReady =1;     
0055:  BSF    2E.7
.................... 	if( r_a==1) 
0056:  DECFSZ 3D,W
0057:  GOTO   05D
.................... 	{ 
.................... 		address = data[1]; 
0058:  MOVF   31,W
0059:  MOVWF  43
.................... 		command =data[0];						 
005A:  MOVF   30,W
005B:  MOVWF  44
.................... 	} 
005C:  GOTO   066
.................... 	else if( r_a==0) 
005D:  MOVF   3D,F
005E:  BTFSS  03.2
005F:  GOTO   066
.................... 	{	 
.................... 		address = data[2]; 
0060:  MOVF   32,W
0061:  MOVWF  43
.................... 		command =data[1]; 
0062:  MOVF   31,W
0063:  MOVWF  44
.................... 		databyte=data[0];  
0064:  MOVF   30,W
0065:  MOVWF  45
.................... 	}        
....................     timerOnOff=0; 
0066:  BCF    10.0
....................     intf =0; 
0067:  BCF    0B.1
....................     enable_interrupts(INT_EXT); 
0068:  BSF    0B.4
....................     disable_interrupts(int_timer1); 
0069:  BSF    03.5
006A:  BCF    0C.0
....................     enable_interrupts(INT_RTCC); 
006B:  BCF    03.5
006C:  BSF    0B.5
....................     settling_time = 0; 
006D:  CLRF   36
....................     return; 
006E:  RETURN
.................... } 
....................  
....................  
.................... void commands(void) 
.................... {  
.................... 	command_st =0;	 
*
0399:  CLRF   3F
.................... 	switch(command) 
039A:  MOVF   44,W
039B:  XORLW  64
039C:  BTFSC  03.2
039D:  GOTO   3BA
039E:  XORLW  8E
039F:  BTFSC  03.2
03A0:  GOTO   3CE
03A1:  XORLW  0D
03A2:  BTFSC  03.2
03A3:  GOTO   3E9
03A4:  XORLW  EE
03A5:  BTFSC  03.2
03A6:  GOTO   411
03A7:  XORLW  2A
03A8:  BTFSC  03.2
03A9:  GOTO   4D4
03AA:  XORLW  07
03AB:  BTFSC  03.2
03AC:  GOTO   4D9
03AD:  XORLW  01
03AE:  BTFSC  03.2
03AF:  GOTO   500
03B0:  XORLW  03
03B1:  BTFSC  03.2
03B2:  GOTO   509
03B3:  XORLW  01
03B4:  BTFSC  03.2
03B5:  GOTO   518
03B6:  XORLW  16
03B7:  BTFSC  03.2
03B8:  GOTO   526
03B9:  GOTO   52E
.................... 	{ 
....................  
.................... 	   	case 100:	// goto  level  
.................... 		{   
.................... 			 
.................... 			if(databyte > MaximumLevel ) 
03BA:  MOVF   45,W
03BB:  SUBWF  4E,W
03BC:  BTFSC  03.0
03BD:  GOTO   3C1
.................... 			{ 
....................                 fan_duty=MaximumLevel; 
03BE:  MOVF   4E,W
03BF:  MOVWF  35
.................... 			} 
03C0:  GOTO   3CA
.................... 			else if(databyte< MinimumLevel ) 
03C1:  MOVF   4D,W
03C2:  SUBWF  45,W
03C3:  BTFSC  03.0
03C4:  GOTO   3C8
.................... 		    {			 
....................                 fan_duty=MinimumLevel; 
03C5:  MOVF   4D,W
03C6:  MOVWF  35
.................... 			} 
03C7:  GOTO   3CA
.................... 			else 
.................... 			{		 
....................                 fan_duty=databyte; 
03C8:  MOVF   45,W
03C9:  MOVWF  35
.................... 			} 					 
.................... 			flash_IR(fan_duty);							 
03CA:  MOVF   35,W
03CB:  MOVWF  5F
03CC:  CALL   248
.................... 			break; 
03CD:  GOTO   530
.................... 		} 
.................... 		 
.................... 	/*	case 216:	//dim 
.................... 		case 241:		//ZONE DIM 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{				 
.................... 				if(duty>MinimumLevel) 
.................... 				{							 
.................... 					duty--; 
.................... 					SetDimmLevel(duty);					 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		} 
.................... 		case 220:	//bright 
.................... 		case 240:  //zone  bright 
.................... 		{ 
.................... 			if(l_st==1) 
.................... 			{			 
.................... 				if(duty < MaximumLevel) 
.................... 				{									 
.................... 					duty++; 
.................... 					SetDimmLevel(duty);			 
.................... 				} 
.................... 			} 
.................... 			break; 
.................... 		}*/	 
.................... 	 
.................... 		case 234: // scene select  
.................... 		{ 
.................... 			if(databyte < 17) 
03CE:  MOVF   45,W
03CF:  SUBLW  10
03D0:  BTFSS  03.0
03D1:  GOTO   3E5
.................... 			{				 
.................... 				currentSceen = databyte;			 
03D2:  MOVF   45,W
03D3:  MOVWF  3E
.................... 		        fan_duty = read_EEPROM (currentSceen+SceneStore);	 
03D4:  MOVLW  09
03D5:  ADDWF  3E,W
03D6:  MOVWF  5F
03D7:  MOVF   5F,W
03D8:  BSF    03.5
03D9:  MOVWF  1B
03DA:  BCF    1C.7
03DB:  BSF    1C.0
03DC:  MOVF   1A,W
03DD:  BCF    03.5
03DE:  MOVWF  35
.................... 			     	if(fan_duty<=MinimumLevel) 
03DF:  MOVF   35,W
03E0:  SUBWF  4D,W
03E1:  BTFSS  03.0
03E2:  GOTO   3E5
.................... 					{ 
.................... 						fan_duty=5;		 
03E3:  MOVLW  05
03E4:  MOVWF  35
.................... 					}		 
.................... 			} 
.................... 			flash_IR(fan_duty); 
03E5:  MOVF   35,W
03E6:  MOVWF  5F
03E7:  CALL   248
.................... 			break; 
03E8:  GOTO   530
.................... 		 } 
.................... 		case 231:  // store sceen  
.................... 		{ 
....................  
.................... 			if(databyte < 17) 
03E9:  MOVF   45,W
03EA:  SUBLW  10
03EB:  BTFSS  03.0
03EC:  GOTO   410
.................... 			{				 
.................... 				disable_interrupts (global); 
03ED:  BCF    0B.6
03EE:  BCF    0B.7
03EF:  BTFSC  0B.7
03F0:  GOTO   3EE
.................... 				write_eeprom(databyte+SceneStore,fan_duty); 
03F1:  MOVLW  09
03F2:  ADDWF  45,W
03F3:  MOVWF  5F
03F4:  MOVF   0B,W
03F5:  MOVWF  77
03F6:  BCF    0B.7
03F7:  MOVF   5F,W
03F8:  BSF    03.5
03F9:  MOVWF  1B
03FA:  BCF    03.5
03FB:  MOVF   35,W
03FC:  BSF    03.5
03FD:  MOVWF  1A
03FE:  BCF    1C.7
03FF:  BSF    1C.2
0400:  MOVLW  55
0401:  MOVWF  1D
0402:  MOVLW  AA
0403:  MOVWF  1D
0404:  BSF    1C.1
0405:  BTFSC  1C.1
0406:  GOTO   405
0407:  BCF    1C.2
0408:  MOVF   77,W
0409:  BCF    03.5
040A:  IORWF  0B,F
.................... 				delay_us(5);			 
040B:  GOTO   40C
040C:  GOTO   40D
040D:  NOP
.................... 				enable_interrupts(global);	 
040E:  MOVLW  C0
040F:  IORWF  0B,F
.................... 			} 
.................... 			break; 
0410:  GOTO   530
.................... 		} 
.................... 		case 0x09: 
.................... 		{		 
.................... 				GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
0411:  MOVLW  08
0412:  BSF    03.5
0413:  MOVWF  1B
0414:  BCF    1C.7
0415:  BSF    1C.0
0416:  MOVF   1A,W
0417:  BCF    03.5
0418:  MOVWF  5F
0419:  MOVLW  07
041A:  BSF    03.5
041B:  MOVWF  1B
041C:  BCF    1C.7
041D:  BSF    1C.0
041E:  MOVF   1A,W
041F:  BCF    03.5
0420:  MOVWF  60
0421:  MOVF   5F,W
0422:  MOVWF  4A
0423:  MOVF   60,W
0424:  MOVWF  49
.................... 				gindex = databyte &0x0f;				 
0425:  MOVF   45,W
0426:  ANDLW  0F
0427:  MOVWF  4B
.................... 				switch (databyte & 0x10) 
0428:  MOVF   45,W
0429:  ANDLW  10
042A:  BTFSC  03.2
042B:  GOTO   430
042C:  XORLW  10
042D:  BTFSC  03.2
042E:  GOTO   484
042F:  GOTO   4D3
.................... 				{ 
.................... 					case 0: 
.................... 						{ 
.................... 							bit_clear(GroupSelectReg,gindex); 
0430:  CLRF   7A
0431:  MOVLW  01
0432:  MOVWF  79
0433:  MOVF   4B,W
0434:  MOVWF  77
0435:  BTFSC  03.2
0436:  GOTO   43C
0437:  BCF    03.0
0438:  RLF    79,F
0439:  RLF    7A,F
043A:  DECFSZ 77,F
043B:  GOTO   437
043C:  MOVF   79,W
043D:  XORLW  FF
043E:  MOVWF  77
043F:  MOVLW  FF
0440:  XORWF  7A,F
0441:  MOVF   77,W
0442:  ANDWF  49,F
0443:  MOVF   7A,W
0444:  ANDWF  4A,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0445:  MOVF   49,W
0446:  MOVWF  5F
0447:  MOVF   0B,W
0448:  MOVWF  77
0449:  BCF    0B.7
044A:  MOVLW  07
044B:  BSF    03.5
044C:  MOVWF  1B
044D:  BCF    03.5
044E:  MOVF   49,W
044F:  BSF    03.5
0450:  MOVWF  1A
0451:  BCF    1C.7
0452:  BSF    1C.2
0453:  MOVLW  55
0454:  MOVWF  1D
0455:  MOVLW  AA
0456:  MOVWF  1D
0457:  BSF    1C.1
0458:  BTFSC  1C.1
0459:  GOTO   458
045A:  BCF    1C.2
045B:  MOVF   77,W
045C:  BCF    03.5
045D:  IORWF  0B,F
.................... 							delay_us(10); 
045E:  MOVLW  02
045F:  MOVWF  77
0460:  DECFSZ 77,F
0461:  GOTO   460
0462:  GOTO   463
0463:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
0464:  MOVF   4A,W
0465:  MOVWF  5F
0466:  MOVF   0B,W
0467:  MOVWF  77
0468:  BCF    0B.7
0469:  MOVLW  08
046A:  BSF    03.5
046B:  MOVWF  1B
046C:  BCF    03.5
046D:  MOVF   4A,W
046E:  BSF    03.5
046F:  MOVWF  1A
0470:  BCF    1C.7
0471:  BSF    1C.2
0472:  MOVLW  55
0473:  MOVWF  1D
0474:  MOVLW  AA
0475:  MOVWF  1D
0476:  BSF    1C.1
0477:  BTFSC  1C.1
0478:  GOTO   477
0479:  BCF    1C.2
047A:  MOVF   77,W
047B:  BCF    03.5
047C:  IORWF  0B,F
....................  							delay_us(10); 
047D:  MOVLW  02
047E:  MOVWF  77
047F:  DECFSZ 77,F
0480:  GOTO   47F
0481:  GOTO   482
0482:  NOP
.................... 							break; 
0483:  GOTO   4D3
.................... 						} 
.................... 					case 16: 
.................... 						{ 
.................... 							bit_set(GroupSelectReg,gindex); 
0484:  CLRF   7A
0485:  MOVLW  01
0486:  MOVWF  79
0487:  MOVF   4B,W
0488:  MOVWF  77
0489:  BTFSC  03.2
048A:  GOTO   490
048B:  BCF    03.0
048C:  RLF    79,F
048D:  RLF    7A,F
048E:  DECFSZ 77,F
048F:  GOTO   48B
0490:  MOVF   79,W
0491:  IORWF  49,F
0492:  MOVF   7A,W
0493:  IORWF  4A,F
.................... 							write_eeprom(Group_07Store  ,make8(GroupSelectReg,0)); 
0494:  MOVF   49,W
0495:  MOVWF  5F
0496:  MOVF   0B,W
0497:  MOVWF  77
0498:  BCF    0B.7
0499:  MOVLW  07
049A:  BSF    03.5
049B:  MOVWF  1B
049C:  BCF    03.5
049D:  MOVF   49,W
049E:  BSF    03.5
049F:  MOVWF  1A
04A0:  BCF    1C.7
04A1:  BSF    1C.2
04A2:  MOVLW  55
04A3:  MOVWF  1D
04A4:  MOVLW  AA
04A5:  MOVWF  1D
04A6:  BSF    1C.1
04A7:  BTFSC  1C.1
04A8:  GOTO   4A7
04A9:  BCF    1C.2
04AA:  MOVF   77,W
04AB:  BCF    03.5
04AC:  IORWF  0B,F
.................... 							delay_us(10); 
04AD:  MOVLW  02
04AE:  MOVWF  77
04AF:  DECFSZ 77,F
04B0:  GOTO   4AF
04B1:  GOTO   4B2
04B2:  NOP
.................... 							write_eeprom(Group_815Store,make8(GroupSelectReg,1)); 
04B3:  MOVF   4A,W
04B4:  MOVWF  5F
04B5:  MOVF   0B,W
04B6:  MOVWF  77
04B7:  BCF    0B.7
04B8:  MOVLW  08
04B9:  BSF    03.5
04BA:  MOVWF  1B
04BB:  BCF    03.5
04BC:  MOVF   4A,W
04BD:  BSF    03.5
04BE:  MOVWF  1A
04BF:  BCF    1C.7
04C0:  BSF    1C.2
04C1:  MOVLW  55
04C2:  MOVWF  1D
04C3:  MOVLW  AA
04C4:  MOVWF  1D
04C5:  BSF    1C.1
04C6:  BTFSC  1C.1
04C7:  GOTO   4C6
04C8:  BCF    1C.2
04C9:  MOVF   77,W
04CA:  BCF    03.5
04CB:  IORWF  0B,F
....................  							delay_us(10); 
04CC:  MOVLW  02
04CD:  MOVWF  77
04CE:  DECFSZ 77,F
04CF:  GOTO   4CE
04D0:  GOTO   4D1
04D1:  NOP
.................... 							break; 
04D2:  GOTO   4D3
.................... 						} 
.................... 					 
.................... 					default: break; 
....................  
.................... 				} 
.................... 				break ; 
04D3:  GOTO   530
.................... 		} 
.................... 	/*	case 0x22:    // store  short  aress  
.................... 		{ 
.................... 			if(databyte <64) 
.................... 			{ 
.................... 					lampid = databyte; 
.................... 					write_eeprom(ShortAddressStore ,lampid); 
.................... 					delay_us(10); 
.................... 			} 
.................... 		 
.................... 			break;		 
.................... 		} 
.................... 	*/ 
.................... 		case 0x23:    // write  DTR  
.................... 		{ 
.................... 					DTR = databyte;	 
04D4:  MOVF   45,W
04D5:  MOVWF  5A
.................... 					DTR_Ready =1; 
04D6:  MOVLW  01
04D7:  MOVWF  5C
.................... 					break; 
04D8:  GOTO   530
.................... 		} 
.................... 		case 0x24:    // write  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 					 
.................... 				DwriteLocation = databyte;	 
04D9:  MOVF   45,W
04DA:  MOVWF  5B
.................... 				if(DTR_Ready ==1 && DwriteLocation<33 ) 
04DB:  DECFSZ 5C,W
04DC:  GOTO   4FE
04DD:  MOVF   5B,W
04DE:  SUBLW  20
04DF:  BTFSS  03.0
04E0:  GOTO   4FE
.................... 				{ 
.................... 					DTR_Ready =0; 
04E1:  CLRF   5C
.................... 					write_eeprom(DwriteLocation,DTR); 
04E2:  MOVF   0B,W
04E3:  MOVWF  77
04E4:  BCF    0B.7
04E5:  MOVF   5B,W
04E6:  BSF    03.5
04E7:  MOVWF  1B
04E8:  BCF    03.5
04E9:  MOVF   5A,W
04EA:  BSF    03.5
04EB:  MOVWF  1A
04EC:  BCF    1C.7
04ED:  BSF    1C.2
04EE:  MOVLW  55
04EF:  MOVWF  1D
04F0:  MOVLW  AA
04F1:  MOVWF  1D
04F2:  BSF    1C.1
04F3:  BTFSC  1C.1
04F4:  GOTO   4F3
04F5:  BCF    1C.2
04F6:  MOVF   77,W
04F7:  BCF    03.5
04F8:  IORWF  0B,F
.................... 					DELAY_US(20); 
04F9:  MOVLW  06
04FA:  MOVWF  77
04FB:  DECFSZ 77,F
04FC:  GOTO   4FB
04FD:  NOP
.................... 				} 
.................... 			init_from_eeprom(); 
04FE:  CALL   12D
.................... 			break; 
04FF:  GOTO   530
.................... 		} 
.................... 		case 0x25:    // Read  DTR  to  adress  location  in data  byte  
.................... 		{ 
.................... 				tx_buffer[2]=lampid;tx_buffer[1]=DTR; txmit(2,2);  /////////priority changed 
0500:  MOVF   5D,W
0501:  MOVWF  3C
0502:  MOVF   5A,W
0503:  MOVWF  3B
0504:  MOVLW  02
0505:  MOVWF  5F
0506:  MOVWF  60
0507:  CALL   32D
.................... 				break;			 
0508:  GOTO   530
.................... 		} 
.................... 		case 0x26:    // Read  eeprom  and  store  in dtr   to  adress  location  in data  byte  
.................... 		{ 
.................... 				DwriteLocation = databyte;	 
0509:  MOVF   45,W
050A:  MOVWF  5B
.................... 				if( DwriteLocation<33 ) 
050B:  MOVF   5B,W
050C:  SUBLW  20
050D:  BTFSS  03.0
050E:  GOTO   517
.................... 				{ 
.................... 					DTR=Read_eeprom(DwriteLocation); 
050F:  MOVF   5B,W
0510:  BSF    03.5
0511:  MOVWF  1B
0512:  BCF    1C.7
0513:  BSF    1C.0
0514:  MOVF   1A,W
0515:  BCF    03.5
0516:  MOVWF  5A
.................... 				}	 
.................... 				break;				 
0517:  GOTO   530
.................... 		} 
.................... 		case 0x27: 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=Read_eeprom(0);  
0518:  MOVF   5D,W
0519:  MOVWF  3C
051A:  BSF    03.5
051B:  CLRF   1B
051C:  BCF    1C.7
051D:  BSF    1C.0
051E:  MOVF   1A,W
051F:  BCF    03.5
0520:  MOVWF  3B
.................... 	    	txmit(2,2); 
0521:  MOVLW  02
0522:  MOVWF  5F
0523:  MOVWF  60
0524:  CALL   32D
.................... 		 
.................... 			break; 
0525:  GOTO   530
....................  
.................... 		} 
.................... 		case 0x31: //////////////// case for device type query ///////////////// 
.................... 		{ 
.................... 			tx_buffer[2]=lampid;tx_buffer[1]=device_type;  
0526:  MOVF   5D,W
0527:  MOVWF  3C
0528:  MOVLW  02
0529:  MOVWF  3B
.................... 			txmit(2,2); 
052A:  MOVWF  5F
052B:  MOVWF  60
052C:  CALL   32D
.................... 					 
.................... 			 
.................... 			break; 
052D:  GOTO   530
....................  
.................... 		} 
.................... 		default: 
.................... 		{ 
.................... 			command_st=1; 
052E:  MOVLW  01
052F:  MOVWF  3F
.................... 			break; 
.................... 		} 
.................... 	} 
.................... 	if(command_st==0) 
0530:  MOVF   3F,F
0531:  BTFSS  03.2
0532:  GOTO   549
.................... 	{ 		 
.................... 		  write_eeprom(PowerOnLevelStore,fan_duty);		 
0533:  MOVF   0B,W
0534:  MOVWF  77
0535:  BCF    0B.7
0536:  BSF    03.5
0537:  CLRF   1B
0538:  BCF    03.5
0539:  MOVF   35,W
053A:  BSF    03.5
053B:  MOVWF  1A
053C:  BCF    1C.7
053D:  BSF    1C.2
053E:  MOVLW  55
053F:  MOVWF  1D
0540:  MOVLW  AA
0541:  MOVWF  1D
0542:  BSF    1C.1
0543:  BTFSC  1C.1
0544:  GOTO   543
0545:  BCF    1C.2
0546:  MOVF   77,W
0547:  BCF    03.5
0548:  IORWF  0B,F
.................... 	} 
....................  
....................  
.................... return; 
.................... } 
....................  
.................... /* 
.................... void zero() 
.................... { 
....................  
.................... /////////////////////////////////////// 
....................   
....................  setup_ccp1(CCP_PWM); 
....................   set_pwm1_duty((int16)50); 
....................   delay_us(562); 
....................   setup_ccp1(CCP_OFF); 
....................   delay_us(562); 
.................... /////////////////////////////////////// 
....................  
.................... } 
.................... */ 
....................  
.................... /* 
.................... void one() 
.................... { 
....................   setup_ccp1(CCP_PWM); 
....................   set_pwm1_duty((int16)50); 
....................   delay_us(562); 
....................   setup_ccp1(CCP_OFF); 
....................   delay_us(1687); 
....................  
.................... } 
.................... */ 
....................  
.................... /* 
....................  
.................... void power() 
.................... { 
....................  
.................... 	  disable_interrupts(int_rtcc); 
.................... 	  setup_ccp1(CCP_PWM); 
.................... 	  set_pwm1_duty((int16)50); 
....................   	  delay_us(9000); 
....................       setup_ccp1(CCP_OFF); 
....................  	  delay_us(4500); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  one(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  one(); 
.................... 	  zero(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  zero(); 
.................... 	  one(); 
.................... 	  one(); 
.................... 	  zero(); 
.................... 	  zero(); 
.................... 	  setup_ccp1(CCP_OFF); 
.................... 	  enable_interrupts(int_rtcc); 
....................  
.................... } 
.................... */ 
....................  
....................  
.................... /* 
.................... void speed_plus() 
.................... { 
.................... 	disable_interrupts(int_rtcc); 
.................... 	setup_ccp1(CCP_PWM); 
.................... 	set_pwm1_duty((int16)50); 
.................... 	delay_us(9000); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	delay_us(4500); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	enable_interrupts(int_rtcc); 
.................... 	return; 
....................  
.................... } 
.................... */ 
....................  
....................  
.................... /* 
.................... void speed_minus() 
.................... { 
.................... 	disable_interrupts(int_rtcc); 
.................... 	setup_ccp1(CCP_PWM); 
.................... 	set_pwm1_duty((int16)50); 
.................... 	delay_us(9000); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	delay_us(4500); 
.................... 	zero();  
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	enable_interrupts(int_rtcc); 
.................... 	return; 
....................  
.................... } 
.................... */ 
....................  
.................... /* 
.................... void led() 
.................... { 
.................... 	disable_interrupts(int_rtcc); 
.................... 	setup_ccp1(CCP_PWM); 
.................... 	set_pwm1_duty((int16)50); 
.................... 	delay_us(9000); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	delay_us(4500); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero();	 
.................... 	one();	 
.................... 	one();	 
.................... 	one();	 
.................... 	one();	 
.................... 	one();	 
.................... 	one();	 
.................... 	one();	 
.................... 	zero();	 
.................... 	one();	 
.................... 	zero();	 
.................... 	zero();	 
.................... 	one();	 
.................... 	zero();		 
.................... 	zero();	 
.................... 	zero();	 
.................... 	one();	 
.................... 	zero();	 
.................... 	one();	 
.................... 	one();	 
.................... 	zero();	 
.................... 	zero(); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	enable_interrupts(int_rtcc); 
.................... 	return; 
....................  
.................... } 
.................... */ 
....................  
.................... /* 
.................... void boost() 
.................... { 
....................  
.................... ///////////////////////////////////////////////////// 
....................  
.................... 	disable_interrupts(int_rtcc); 
.................... 	setup_ccp1(CCP_PWM); 
.................... 	set_pwm1_duty((int16)50); 
.................... 	delay_us(9000); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	delay_us(4500); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	enable_interrupts(int_rtcc); 
.................... //////////////////////////////////////////////////// 
....................  
.................... 	return; 
....................  
.................... } 
.................... */ 
....................  
....................  
.................... /* 
.................... void timer() 
.................... { 
....................  
.................... 	disable_interrupts(int_rtcc); 
.................... 	setup_ccp1(CCP_PWM); 
.................... 	set_pwm1_duty((int16)50); 
.................... 	delay_us(9000); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	delay_us(4500); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero();  
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	enable_interrupts(int_rtcc); 
.................... 	return; 
....................  
....................  
.................... } 
.................... */ 
....................  
.................... /* 
.................... void sleeper() 
.................... { 
....................  
.................... 	disable_interrupts(int_rtcc); 
.................... 	setup_ccp1(CCP_PWM); 
.................... 	set_pwm1_duty((int16)50); 
.................... 	delay_us(9000); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	delay_us(4500); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	one(); 
.................... 	one(); 
.................... 	one(); 
.................... 	zero(); 
.................... 	zero(); 
.................... 	setup_ccp1(CCP_OFF); 
.................... 	enable_interrupts(int_rtcc); 
.................... 	return; 
....................  
....................  
.................... } 
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void flash_IR(unsigned char speed)/// 1910 
.................... {	 
....................  
.................... if(speed>=0 && speed<=10) 
*
0248:  MOVF   5F,W
0249:  SUBLW  0A
024A:  BTFSS  03.0
024B:  GOTO   24E
.................... { 
.................... dummy_speed=0; 
024C:  CLRF   5E
.................... /// fan off function 
.................... } 
024D:  GOTO   294
.................... else if(speed>10 && speed<=20)  // speed 1 
024E:  MOVF   5F,W
024F:  SUBLW  0A
0250:  BTFSC  03.0
0251:  GOTO   259
0252:  MOVF   5F,W
0253:  SUBLW  14
0254:  BTFSS  03.0
0255:  GOTO   259
.................... { 
.................... // speed 1 
.................... dummy_speed=1; 
0256:  MOVLW  01
0257:  MOVWF  5E
.................... } 
0258:  GOTO   294
.................... else if(speed>20 && speed<=30)   // speed 2 
0259:  MOVF   5F,W
025A:  SUBLW  14
025B:  BTFSC  03.0
025C:  GOTO   264
025D:  MOVF   5F,W
025E:  SUBLW  1E
025F:  BTFSS  03.0
0260:  GOTO   264
.................... { 
.................... // speed 2 
.................... dummy_speed=2; 
0261:  MOVLW  02
0262:  MOVWF  5E
....................  
.................... } 
0263:  GOTO   294
.................... else if(speed>30 && speed<=50) // speed 3 
0264:  MOVF   5F,W
0265:  SUBLW  1E
0266:  BTFSC  03.0
0267:  GOTO   26F
0268:  MOVF   5F,W
0269:  SUBLW  32
026A:  BTFSS  03.0
026B:  GOTO   26F
.................... { 
.................... // speed 3 
.................... dummy_speed=3; 
026C:  MOVLW  03
026D:  MOVWF  5E
.................... } 
026E:  GOTO   294
.................... else if(speed>50 && speed<=70) // speed 4 
026F:  MOVF   5F,W
0270:  SUBLW  32
0271:  BTFSC  03.0
0272:  GOTO   27A
0273:  MOVF   5F,W
0274:  SUBLW  46
0275:  BTFSS  03.0
0276:  GOTO   27A
.................... { 
.................... // speed 4 
.................... dummy_speed=4; 
0277:  MOVLW  04
0278:  MOVWF  5E
.................... } 
0279:  GOTO   294
.................... else if(speed>70 && speed<=90) // speed 5 
027A:  MOVF   5F,W
027B:  SUBLW  46
027C:  BTFSC  03.0
027D:  GOTO   285
027E:  MOVF   5F,W
027F:  SUBLW  5A
0280:  BTFSS  03.0
0281:  GOTO   285
.................... { 
.................... // speed 5 
.................... dummy_speed=5; 
0282:  MOVLW  05
0283:  MOVWF  5E
.................... } 
0284:  GOTO   294
.................... else if(speed>90 && speed<=100)  // speed 6 
0285:  MOVF   5F,W
0286:  SUBLW  5A
0287:  BTFSC  03.0
0288:  GOTO   290
0289:  MOVF   5F,W
028A:  SUBLW  64
028B:  BTFSS  03.0
028C:  GOTO   290
.................... { 
.................... // fan full on command 
.................... dummy_speed=6; 
028D:  MOVLW  06
028E:  MOVWF  5E
.................... } 
028F:  GOTO   294
.................... else if(speed>100) 
0290:  MOVF   5F,W
0291:  SUBLW  64
0292:  BTFSS  03.0
.................... { 
.................... dummy_speed=0; 
0293:  CLRF   5E
.................... } 
.................... if(dummy_speed == 0) 
0294:  MOVF   5E,F
0295:  BTFSS  03.2
0296:  GOTO   29C
.................... { 
.................... 	output_low(fan_pin); 
0297:  BSF    03.5
0298:  BCF    06.5
0299:  BCF    03.5
029A:  BCF    06.5
.................... } 
029B:  GOTO   2BC
.................... else 
.................... { 
.................... 	output_high(fan_pin); 
029C:  BSF    03.5
029D:  BCF    06.5
029E:  BCF    03.5
029F:  BSF    06.5
.................... 	delay_ms(3000); 
02A0:  MOVLW  0C
02A1:  MOVWF  60
02A2:  MOVLW  FA
02A3:  MOVWF  61
02A4:  CALL   233
02A5:  DECFSZ 60,F
02A6:  GOTO   2A2
.................... 	for(i=0;i<=dummy_speed;i++) 
02A7:  CLRF   37
02A8:  MOVF   37,W
02A9:  SUBWF  5E,W
02AA:  BTFSS  03.0
02AB:  GOTO   2BC
.................... 	{ 
.................... 	output_low(fan_pin); 
02AC:  BSF    03.5
02AD:  BCF    06.5
02AE:  BCF    03.5
02AF:  BCF    06.5
.................... 	delay_ms(250); 
02B0:  MOVLW  FA
02B1:  MOVWF  61
02B2:  CALL   233
.................... 	output_high(fan_pin); 
02B3:  BSF    03.5
02B4:  BCF    06.5
02B5:  BCF    03.5
02B6:  BSF    06.5
.................... 	delay_ms(250); 
02B7:  MOVLW  FA
02B8:  MOVWF  61
02B9:  CALL   233
02BA:  INCF   37,F
02BB:  GOTO   2A8
.................... 	} 
.................... } 
....................  
.................... return; 
02BC:  RETURN
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... void init_from_eeprom(void) 
.................... { 
.................... GroupSelectReg = MAKE16(read_EEPROM (Group_815Store ),read_EEPROM (Group_07Store));	 
*
012D:  MOVLW  08
012E:  BSF    03.5
012F:  MOVWF  1B
0130:  BCF    1C.7
0131:  BSF    1C.0
0132:  MOVF   1A,W
0133:  BCF    03.5
0134:  MOVWF  5F
0135:  MOVLW  07
0136:  BSF    03.5
0137:  MOVWF  1B
0138:  BCF    1C.7
0139:  BSF    1C.0
013A:  MOVF   1A,W
013B:  BCF    03.5
013C:  MOVWF  60
013D:  MOVF   5F,W
013E:  MOVWF  4A
013F:  MOVF   60,W
0140:  MOVWF  49
.................... delay_us(10); 
0141:  MOVLW  02
0142:  MOVWF  77
0143:  DECFSZ 77,F
0144:  GOTO   143
0145:  GOTO   146
0146:  NOP
.................... PowerOnLevel 		= read_EEPROM (PowerOnLevelStore); 
0147:  BSF    03.5
0148:  CLRF   1B
0149:  BCF    1C.7
014A:  BSF    1C.0
014B:  MOVF   1A,W
014C:  BCF    03.5
014D:  MOVWF  59
.................... delay_us(10);  
014E:  MOVLW  02
014F:  MOVWF  77
0150:  DECFSZ 77,F
0151:  GOTO   150
0152:  GOTO   153
0153:  NOP
.................... SystemFailureLevel	= read_EEPROM ( SystemFailureLevelStore );  
0154:  MOVLW  01
0155:  BSF    03.5
0156:  MOVWF  1B
0157:  BCF    1C.7
0158:  BSF    1C.0
0159:  MOVF   1A,W
015A:  BCF    03.5
015B:  MOVWF  4F
.................... delay_us(10);	     
015C:  MOVLW  02
015D:  MOVWF  77
015E:  DECFSZ 77,F
015F:  GOTO   15E
0160:  GOTO   161
0161:  NOP
.................... MinimumLevel		= read_EEPROM ( MinimumLevelStore );    
0162:  MOVLW  02
0163:  BSF    03.5
0164:  MOVWF  1B
0165:  BCF    1C.7
0166:  BSF    1C.0
0167:  MOVF   1A,W
0168:  BCF    03.5
0169:  MOVWF  4D
.................... delay_us(10);       	 
016A:  MOVLW  02
016B:  MOVWF  77
016C:  DECFSZ 77,F
016D:  GOTO   16C
016E:  GOTO   16F
016F:  NOP
.................... MaximumLevel 		= read_EEPROM ( MaximumLevelStore);  
0170:  MOVLW  03
0171:  BSF    03.5
0172:  MOVWF  1B
0173:  BCF    1C.7
0174:  BSF    1C.0
0175:  MOVF   1A,W
0176:  BCF    03.5
0177:  MOVWF  4E
.................... delay_us(10);  		 
0178:  MOVLW  02
0179:  MOVWF  77
017A:  DECFSZ 77,F
017B:  GOTO   17A
017C:  GOTO   17D
017D:  NOP
.................... FadeRate 			= read_EEPROM ( FadeRateStore); 
017E:  MOVLW  04
017F:  BSF    03.5
0180:  MOVWF  1B
0181:  BCF    1C.7
0182:  BSF    1C.0
0183:  MOVF   1A,W
0184:  BCF    03.5
0185:  MOVWF  50
.................... delay_us(10); 
0186:  MOVLW  02
0187:  MOVWF  77
0188:  DECFSZ 77,F
0189:  GOTO   188
018A:  GOTO   18B
018B:  NOP
.................... FadeTime 			= read_EEPROM ( FadeTimeStore ); 
018C:  MOVLW  05
018D:  BSF    03.5
018E:  MOVWF  1B
018F:  BCF    1C.7
0190:  BSF    1C.0
0191:  MOVF   1A,W
0192:  BCF    03.5
0193:  MOVWF  51
.................... delay_us(10); 
0194:  MOVLW  02
0195:  MOVWF  77
0196:  DECFSZ 77,F
0197:  GOTO   196
0198:  GOTO   199
0199:  NOP
.................... lampid 				= read_EEPROM ( ShortAddressStore ); 
019A:  MOVLW  06
019B:  BSF    03.5
019C:  MOVWF  1B
019D:  BCF    1C.7
019E:  BSF    1C.0
019F:  MOVF   1A,W
01A0:  BCF    03.5
01A1:  MOVWF  5D
.................... delay_us(10); 
01A2:  MOVLW  02
01A3:  MOVWF  77
01A4:  DECFSZ 77,F
01A5:  GOTO   1A4
01A6:  GOTO   1A7
01A7:  NOP
....................  
.................... RandomAddress0 		= read_EEPROM ( RandomAddressStore0);  
01A8:  MOVLW  19
01A9:  BSF    03.5
01AA:  MOVWF  1B
01AB:  BCF    1C.7
01AC:  BSF    1C.0
01AD:  MOVF   1A,W
01AE:  BCF    03.5
01AF:  MOVWF  52
.................... delay_us(10);   
01B0:  MOVLW  02
01B1:  MOVWF  77
01B2:  DECFSZ 77,F
01B3:  GOTO   1B2
01B4:  GOTO   1B5
01B5:  NOP
.................... RandomAddress1 		= read_EEPROM ( RandomAddressStore1);  
01B6:  MOVLW  1A
01B7:  BSF    03.5
01B8:  MOVWF  1B
01B9:  BCF    1C.7
01BA:  BSF    1C.0
01BB:  MOVF   1A,W
01BC:  BCF    03.5
01BD:  MOVWF  53
.................... delay_us(10); 
01BE:  MOVLW  02
01BF:  MOVWF  77
01C0:  DECFSZ 77,F
01C1:  GOTO   1C0
01C2:  GOTO   1C3
01C3:  NOP
.................... RandomAddress2 		= read_EEPROM ( RandomAddressStore2); 
01C4:  MOVLW  1B
01C5:  BSF    03.5
01C6:  MOVWF  1B
01C7:  BCF    1C.7
01C8:  BSF    1C.0
01C9:  MOVF   1A,W
01CA:  BCF    03.5
01CB:  MOVWF  54
.................... delay_us(10); 
01CC:  MOVLW  02
01CD:  MOVWF  77
01CE:  DECFSZ 77,F
01CF:  GOTO   1CE
01D0:  GOTO   1D1
01D1:  NOP
....................   		 
.................... FastFadeTime 		= read_EEPROM ( FastFadeTimeStore);  
01D2:  MOVLW  1C
01D3:  BSF    03.5
01D4:  MOVWF  1B
01D5:  BCF    1C.7
01D6:  BSF    1C.0
01D7:  MOVF   1A,W
01D8:  BCF    03.5
01D9:  MOVWF  55
.................... delay_us(10); 		 
01DA:  MOVLW  02
01DB:  MOVWF  77
01DC:  DECFSZ 77,F
01DD:  GOTO   1DC
01DE:  GOTO   1DF
01DF:  NOP
.................... FailureStatus 		= read_EEPROM ( FailureStatusStore);  
01E0:  MOVLW  1D
01E1:  BSF    03.5
01E2:  MOVWF  1B
01E3:  BCF    1C.7
01E4:  BSF    1C.0
01E5:  MOVF   1A,W
01E6:  BCF    03.5
01E7:  MOVWF  56
.................... delay_us(10);  
01E8:  MOVLW  02
01E9:  MOVWF  77
01EA:  DECFSZ 77,F
01EB:  GOTO   1EA
01EC:  GOTO   1ED
01ED:  NOP
.................... OperatingMode 		= read_EEPROM ( OperatingModeStore);  
01EE:  MOVLW  1E
01EF:  BSF    03.5
01F0:  MOVWF  1B
01F1:  BCF    1C.7
01F2:  BSF    1C.0
01F3:  MOVF   1A,W
01F4:  BCF    03.5
01F5:  MOVWF  57
.................... delay_us(10); 
01F6:  MOVLW  02
01F7:  MOVWF  77
01F8:  DECFSZ 77,F
01F9:  GOTO   1F8
01FA:  GOTO   1FB
01FB:  NOP
.................... DimmingCurv 		= read_EEPROM ( DimmingCurveStore); 
01FC:  MOVLW  1F
01FD:  BSF    03.5
01FE:  MOVWF  1B
01FF:  BCF    1C.7
0200:  BSF    1C.0
0201:  MOVF   1A,W
0202:  BCF    03.5
0203:  MOVWF  58
.................... delay_us(10);  
0204:  MOVLW  02
0205:  MOVWF  77
0206:  DECFSZ 77,F
0207:  GOTO   206
0208:  GOTO   209
0209:  NOP
.................... zoneid=read_EEPROM(zoneidstore); 
020A:  MOVLW  20
020B:  BSF    03.5
020C:  MOVWF  1B
020D:  BCF    1C.7
020E:  BSF    1C.0
020F:  MOVF   1A,W
0210:  BCF    03.5
0211:  MOVWF  41
0212:  RETURN
.................... } 
.................... /* 
....................  
.................... void speed_one(void) 
.................... { 
.................... 	 
.................... //	delay_ms(750); 
.................... } 
....................  
.................... void speed_two(void) 
.................... { 
.................... 	 
.................... 	 
.................... } 
....................  
.................... void speed_three(void) 
.................... { 
.................... 	 
.................... //	delay_ms(750); 
.................... } 
....................  
.................... void speed_four(void) 
.................... { 
.................... 	 
.................... //	delay_ms(750); 
.................... } 
....................  
.................... void speed_five(void) 
.................... { 
....................  
.................... //	delay_ms(750); 
.................... } 
....................  
.................... void speed_six(void) 
.................... { 
....................  
.................... //	delay_ms(750); 
.................... } 
....................  
.................... void speed_zero(void) 
.................... { 
.................... 	 
.................... } 
.................... */ 

Configuration Fuses:
   Word  1: 1F38   NOWDT NOPUT INTRC_IO MCLR NOBROWNOUT NOLVP NOCPD PROTECT

ROM data:
002100: 0064 0032 0000 0064 0005 0006 0080 0001 
002108: 0000 0006 0007 0008 

002120: 00DB 
